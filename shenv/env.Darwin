#!/bin/bash

# shellcheck source=/dev/null

# Set up our charter sparse bundle
if [[ -h "$HOME/src/charter" ]];then
  if [[ ! -d "$HOME/src/charter" ]];then
    /usr/bin/base64 -D "$HOME/.secure_credentials" | hdiutil attach "$HOME/Documents/secure.sparsebundle" -stdinpass
  fi
fi

BREW_CORE_PATH="/usr/local/opt/findutils/libexec/gnubin"
BREW_FIND_PATH="/usr/local/opt/coreutils/libexec/gnubin"

export RUBY_HOME="/usr/local/opt/ruby"

export JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home"
export GROOVY_HOME="/usr/local/opt/groovy/libexec"
export ANT_HOME="/usr/local/opt/ant/libexec"
export MYSQL_HOME="/usr/local/mysql"
export JMETER_HOME="/usr/local/jmeter"
# export GOROOT="/usr/local/go"
export GOROOT="/usr/local/opt/go/libexec"
export GOPATH="$HOME/src/gocode"

export s3bucket="s3://com.charter.aesd.engprod.sshsec"

export MANPAGER="less -X"

# Prefer English UTF-8
export LANG="en_US.UTF-8"
export LC_ALL="en_US.UTF-8"

# Make all of the OS X apps from $HOME/Applications, 
# /Applications and /Applications/Utilties into command
# line aliases to open them easily.
#
# e.g. BBEdit.app gets an alias of:
#   alias bbedit='open -a BBEdit.app'
function foomagick() {
  rm -f ~/.foomagick.tmp
  local MYAPPS="$HOME/Applications"
  local FOOM="$HOME/.foomagick.tmp"
  rm -f "$FOOM"
  touch "$FOOM"
  /bin/ls /Applications /Applications/Utilities "${MYAPPS}" | /usr/bin/grep "\.app" | /usr/bin/grep -v iWork |\
  while read -r APP
  do
    [[ "$APP" == "Docker.app" ]] && continue
    [[ "$APP" == "Kitematic (Beta).app" ]] && continue
    [[ "$APP" == "OneNote Importer (Preview).app" ]] && continue
    # Clean it up
    a=${APP// /}
    a=${a//\'/}
    a=$(echo "$a" | tr "[:upper:]" "[:lower:]")
    echo alias "${a%.*}='open -a \"${APP%.*}\"'" >> "${FOOM}"
  done
  (echo "alias word='open -a Microsoft\ Word.app'" ; \
  echo "alias excel='open -a Microsoft\ Excel.app'" ; \
  echo "alias chrome='open -a Google\ Chrome.app'" ; \
  echo alias code="'open -a ${HOME}/Applications/Visual\ Studio\ Code.app/Contents/MacOS/Electron'" ; \
  echo alias vscode="'open -a ${HOME}/Applications/Visual\ Studio\ Code.app/Contents/MacOS/Electron'") >> "$FOOM"
  source "$FOOM"
  # rm -f "$FOOM"
}

foomagick

# Trying for a "best of both worlds" approach to locate
# on OS X darwin. Use the faster mdfind. However, this fails
# for partial pathnames like: bin/sudo. So fall back to mlocate
# style for those cases.
function _locate() {
  declare -i nmbr
  nmbr=$(mdfind -name "$*" -count)

  if [ "$nmbr" -gt 0 ];then
    # echo "mdfind -name $*"
    mdfind -name "$@"
  else
    /usr/bin/locate "$@"
  fi
}

alias locate="_locate"

pathmunge() {
  # If the new directory is already in our PATH skip it
  if [ $# -eq 0 ];then
    echo "$PATH" | awk 'BEGIN { RS=":" } ; { print $1 }'
  else
    case "$:${PATH}:" in
      *:"$1":*)
        ;;
      *)
        if [ "$2" == "after" ];then
          PATH="$PATH:$1"
        else
          PATH="$1:$PATH"
        fi
    esac
  fi
}

# Inserted before current path
# So last one ends up being first on PATH
for var in "$JAVA_HOME" "$ANT_HOME" "$HOME" "$GOROOT" "$RUBY_HOME";do
  if [ -d "${var}/bin" ] && [ -r "${var}/bin" ];then
    pathmunge "${var}/bin"
  fi
done

# Add these after the rest of the PATH
for var in "$GROOVY_HOME" "$MYSQL_HOME" "$GOPATH" "$JMETER_HOME"
do
  if [ -d "${var}/bin" ] && [ -r "${var}/bin" ];then
    pathmunge "${var}/bin" after
  fi
done

pathmunge $BREW_CORE_PATH
pathmunge $BREW_FIND_PATH

# Need to do this before sourcing .bash_aliases
HAVE_NVIM=$(command -v nvim)
#echo $HAVE_NVIM

function _update_ps1() {
  PS1=$("$GOPATH/bin/powerline-go" -numeric-exit-codes -modules "nix-shell,venv,user,host,ssh,cwd,perms,jobs,newline,git,hg,exit,root" -error $? -colorize-hostname -cwd-mode plain )
}

if [ "$TERM" != "linux" ] && [ -f "$GOPATH/bin/powerline-go" ]; then
  PROMPT_COMMAND="_update_ps1; $PROMPT_COMMAND"
else
  source "$HOME/.bash_prompt"
fi


EDITOR=/usr/bin/vim
if [ -n "$HAVE_NVIM" ];then
  EDITOR="$HAVE_NVIM"
fi
export EDITOR

# unset pathmunge
unset foomagick
